import type { JSONContent } from '@tiptap/react';
import type { GodModeAnalysisResult, RepoAnalysis } from './types';

/**
 * Generates a full TipTap JSONContent document from God Mode analysis results.
 * Each repo gets its own set of sections, primary repo first.
 */
export function generateGodModeDocument(result: GodModeAnalysisResult): JSONContent {
  const content: JSONContent[] = [];

  // Sort: primary repos first
  const sorted = [...result.repos].sort((a, b) => {
    if (a.repoRole === 'primary' && b.repoRole !== 'primary') return -1;
    if (a.repoRole !== 'primary' && b.repoRole === 'primary') return 1;
    return 0;
  });

  // Document header
  content.push(
    heading(1, `System Overview — ${sorted.map((r) => r.repoName).join(' / ')}`),
    paragraph(`Generated on ${new Date(result.generatedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}. This document is auto-generated by God Mode analysis and will be refreshed on schedule.`),
    horizontalRule(),
  );

  // Cross-repo system interaction map (top-level, before individual repos)
  if (sorted.length > 1) {
    content.push(
      heading(2, 'System Interaction Map'),
      paragraph('How these services connect to each other:'),
    );

    const allConnections = sorted.flatMap((r) => r.connections);
    if (allConnections.length > 0) {
      content.push(
        table(
          ['From', 'To', 'Type', 'Description', 'Endpoints / Events'],
          allConnections.map((c) => [
            c.fromRepo,
            c.toRepo,
            c.connectionType.toUpperCase(),
            c.description,
            (c.endpoints || []).join(', '),
          ]),
        ),
      );
    } else {
      content.push(paragraph('No direct connections detected between the configured repositories.'));
    }
    content.push(horizontalRule());
  }

  // Per-repo sections
  for (const repo of sorted) {
    const badge = repo.repoRole === 'primary' ? ' (Primary)' : ' (Secondary)';
    content.push(heading(1, `${repo.repoName}${badge}`));
    content.push(paragraph(repo.description));

    // 1. Contributors
    content.push(...contributorsSection(repo));

    // 2. PMs
    content.push(...pmsSection(repo));

    // 3. Tech Stack
    content.push(...techStackSection(repo));

    // 4. Setup Runbook
    content.push(...setupSection(repo));

    // 5. API Surface
    content.push(...apiSurfaceSection(repo));

    // 6. Domain Glossary
    content.push(...glossarySection(repo));

    // 7. Hot Zones
    content.push(...hotZonesSection(repo));

    // 8. Error Taxonomy
    content.push(...errorSection(repo));

    // 9. Architecture Decisions
    content.push(...archDecisionsSection(repo));

    content.push(horizontalRule());
  }

  return { type: 'doc', content };
}

// ─── Section Generators ───────────────────────────────────────

function contributorsSection(repo: RepoAnalysis): JSONContent[] {
  return [
    heading(2, 'Contributors'),
    table(
      ['Name', 'GitHub', 'Commits', 'Lines Added', 'Lines Removed', 'Last Active'],
      repo.contributors.map((c) => [
        c.name,
        `@${c.github}`,
        String(c.commits),
        `+${c.linesAdded.toLocaleString()}`,
        `-${c.linesRemoved.toLocaleString()}`,
        c.lastActive,
      ]),
    ),
  ];
}

function pmsSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.pms.length === 0) {
    return [heading(2, 'Product Managers'), paragraph('No PMs tagged for this repository.')];
  }
  return [
    heading(2, 'Product Managers'),
    bulletList(repo.pms.map((pm) => `${pm.name}${pm.github ? ` (@${pm.github})` : ''}`)),
  ];
}

function techStackSection(repo: RepoAnalysis): JSONContent[] {
  return [
    heading(2, 'Tech Stack'),
    bulletList([
      `Languages / Frameworks: ${repo.techStack.join(', ')}`,
      `Test Frameworks: ${repo.testFrameworks.join(', ')}`,
      `CI/CD: ${repo.cicdPlatform}`,
    ]),
  ];
}

function setupSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.setupSteps.length === 0) return [];
  return [
    heading(2, 'Environment Setup'),
    paragraph('Follow these steps to get the project running locally:'),
    orderedList(
      repo.setupSteps.map((s) =>
        s.notes
          ? `${s.description}: ${s.command} — ${s.notes}`
          : `${s.description}: ${s.command}`
      ),
    ),
  ];
}

function apiSurfaceSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.apiEndpoints.length === 0) return [];
  return [
    heading(2, 'API Surface'),
    table(
      ['Method', 'Path', 'Description', 'Source File'],
      repo.apiEndpoints.map((e) => [e.method, e.path, e.description, e.sourceFile]),
    ),
  ];
}

function glossarySection(repo: RepoAnalysis): JSONContent[] {
  if (repo.glossary.length === 0) return [];
  return [
    heading(2, 'Domain Glossary'),
    paragraph('Non-obvious terms found in the codebase with inferred definitions:'),
    table(
      ['Term', 'Definition', 'Occurrences', 'Key Files'],
      repo.glossary.map((g) => [
        g.term,
        g.inferredDefinition,
        String(g.occurrences),
        g.files.slice(0, 2).join(', '),
      ]),
    ),
  ];
}

function hotZonesSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.hotZones.length === 0) return [];
  return [
    heading(2, 'Hot Zones (High-Churn Files)'),
    paragraph('Files with the most changes in the last 6 months — likely areas you will touch first:'),
    table(
      ['File', 'Changes', 'Last Changed', 'Top Contributors', 'Why It Changes'],
      repo.hotZones.map((h) => [
        h.filePath,
        String(h.changeCount),
        h.lastChanged,
        h.contributors.join(', '),
        h.description,
      ]),
    ),
  ];
}

function errorSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.errorPatterns.length === 0) return [];
  return [
    heading(2, 'Error Taxonomy'),
    paragraph('Custom error classes and their meanings:'),
    table(
      ['Error Class', 'HTTP Status', 'Message', 'Source'],
      repo.errorPatterns.map((e) => [
        e.className,
        e.httpStatus ? String(e.httpStatus) : '—',
        e.message,
        e.sourceFile,
      ]),
    ),
  ];
}

function archDecisionsSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.archDecisions.length === 0) return [];
  return [
    heading(2, 'Architecture Decisions'),
    paragraph('Key technical decisions extracted from commit messages, PRs, and ADRs:'),
    ...repo.archDecisions.map((d) => [
      heading(3, `${d.date} — ${d.summary}`),
      paragraph(`Source: ${d.source}`),
      blockquote(d.context),
    ]).flat(),
  ];
}

// ─── TipTap Node Helpers ──────────────────────────────────────

function heading(level: number, text: string): JSONContent {
  return {
    type: 'heading',
    attrs: { level },
    content: [{ type: 'text', text }],
  };
}

function paragraph(text: string): JSONContent {
  return {
    type: 'paragraph',
    content: [{ type: 'text', text }],
  };
}

function horizontalRule(): JSONContent {
  return { type: 'horizontalRule' };
}

function bulletList(items: string[]): JSONContent {
  return {
    type: 'bulletList',
    content: items.map((item) => ({
      type: 'listItem',
      content: [{ type: 'paragraph', content: [{ type: 'text', text: item }] }],
    })),
  };
}

function orderedList(items: string[]): JSONContent {
  return {
    type: 'orderedList',
    attrs: { start: 1 },
    content: items.map((item) => ({
      type: 'listItem',
      content: [{ type: 'paragraph', content: [{ type: 'text', text: item }] }],
    })),
  };
}

function blockquote(text: string): JSONContent {
  return {
    type: 'blockquote',
    content: [{ type: 'paragraph', content: [{ type: 'text', text }] }],
  };
}

function table(headers: string[], rows: string[][]): JSONContent {
  return {
    type: 'table',
    content: [
      {
        type: 'tableRow',
        content: headers.map((h) => ({
          type: 'tableHeader',
          attrs: { colspan: 1, rowspan: 1 },
          content: [{ type: 'paragraph', content: [{ type: 'text', text: h }] }],
        })),
      },
      ...rows.map((row) => ({
        type: 'tableRow',
        content: row.map((cell) => ({
          type: 'tableCell',
          attrs: { colspan: 1, rowspan: 1 },
          content: [{ type: 'paragraph', content: [{ type: 'text', text: cell }] }],
        })),
      })),
    ],
  };
}
