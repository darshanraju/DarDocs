import type { JSONContent } from '@tiptap/react';
import type { GodModeAnalysisResult, RepoAnalysis } from './types';

/**
 * Generates a full TipTap JSONContent document from God Mode analysis results.
 * Each repo gets its own set of sections, primary repo first.
 *
 * @param swaggerRepos - repo names whose API Surface should be a Swagger embed
 * @param forPreview   - true → render a placeholder; false → real embedBlock node
 */
export function generateGodModeDocument(
  result: GodModeAnalysisResult,
  swaggerRepos: string[] = [],
  forPreview: boolean = true,
): JSONContent {
  const content: JSONContent[] = [];

  // Sort: primary repos first
  const sorted = [...result.repos].sort((a, b) => {
    if (a.repoRole === 'primary' && b.repoRole !== 'primary') return -1;
    if (a.repoRole !== 'primary' && b.repoRole === 'primary') return 1;
    return 0;
  });

  // Document header
  content.push(
    heading(1, `System Overview — ${sorted.map((r) => r.repoName).join(' / ')}`),
    paragraph(`Generated on ${new Date(result.generatedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}. This document is auto-generated by God Mode analysis and will be refreshed on schedule.`),
  );

  // Inline Table of Contents
  content.push({ type: 'tableOfContents' });

  content.push(horizontalRule());

  // System Architecture Diagram
  content.push(
    heading(2, 'System Architecture'),
    archDiagramNode(result),
  );

  // Cross-repo system interaction map (top-level, before individual repos)
  if (sorted.length > 1) {
    content.push(
      heading(2, 'System Interaction Map'),
      paragraph('How these services connect to each other:'),
    );

    const allConnections = sorted.flatMap((r) => r.connections);
    if (allConnections.length > 0) {
      content.push(
        table(
          ['From', 'To', 'Type', 'Description', 'Endpoints / Events'],
          allConnections.map((c) => [
            c.fromRepo,
            c.toRepo,
            c.connectionType.toUpperCase(),
            c.description,
            (c.endpoints || []).join(', '),
          ]),
        ),
      );
    } else {
      content.push(paragraph('No direct connections detected between the configured repositories.'));
    }
    content.push(horizontalRule());
  }

  // Per-repo sections
  for (const repo of sorted) {
    const badge = repo.repoRole === 'primary' ? ' (Primary)' : ' (Secondary)';
    content.push(heading(1, `${repo.repoName}${badge}`));
    content.push(paragraph(repo.description));

    // 1. Contributors
    content.push(...contributorsSection(repo));

    // 2. PMs
    content.push(...pmsSection(repo));

    // 3. Tech Stack
    content.push(...techStackSection(repo));

    // 4. Setup Runbook
    content.push(...setupSection(repo));

    // 5. API Surface
    content.push(...apiSurfaceSection(repo, swaggerRepos.includes(repo.repoName), forPreview));

    // 6. Domain Glossary
    content.push(...glossarySection(repo));

    // 7. Error Taxonomy
    content.push(...errorSection(repo));

    // 8. Architecture Decisions
    content.push(...archDecisionsSection(repo));

    content.push(horizontalRule());
  }

  return { type: 'doc', content };
}

// ─── Section Generators ───────────────────────────────────────

function contributorsSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.contributors.length === 0) {
    return [heading(2, 'Contributors'), paragraph('No contributor data available.')];
  }
  return [
    heading(2, 'Contributors'),
    table(
      ['Name', 'GitHub', 'Commits', 'Lines Added', 'Lines Removed', 'Last Active'],
      repo.contributors.map((c) => [
        c.name,
        `@${c.github}`,
        String(c.commits),
        `+${c.linesAdded.toLocaleString()}`,
        `-${c.linesRemoved.toLocaleString()}`,
        c.lastActive,
      ]),
    ),
  ];
}

function pmsSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.pms.length === 0) {
    return [heading(2, 'Product Managers'), paragraph('No PMs tagged for this repository.')];
  }
  return [
    heading(2, 'Product Managers'),
    bulletList(repo.pms.map((pm) => `${pm.name}${pm.github ? ` (@${pm.github})` : ''}`)),
  ];
}

function techStackSection(repo: RepoAnalysis): JSONContent[] {
  return [
    heading(2, 'Tech Stack'),
    bulletList([
      `Languages / Frameworks: ${repo.techStack.join(', ')}`,
      `Test Frameworks: ${repo.testFrameworks.join(', ')}`,
      `CI/CD: ${repo.cicdPlatform}`,
    ]),
  ];
}

function setupSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.setupSteps.length === 0) return [];
  return [
    heading(2, 'Environment Setup'),
    paragraph('Follow these steps to get the project running locally:'),
    orderedList(
      repo.setupSteps.map((s) =>
        s.notes
          ? `${s.description}: ${s.command} — ${s.notes}`
          : `${s.description}: ${s.command}`
      ),
    ),
  ];
}

function apiSurfaceSection(repo: RepoAnalysis, useSwagger: boolean, forPreview: boolean): JSONContent[] {
  if (repo.apiEndpoints.length === 0) return [];

  if (useSwagger) {
    if (forPreview) {
      // Styled placeholder visible in the read-only preview
      return [
        heading(2, 'API Surface'),
        swaggerPlaceholder(),
      ];
    }
    // Real embedBlock node for the created document
    return [
      heading(2, 'API Surface'),
      { type: 'embedBlock', attrs: { embedType: 'swagger', url: null } },
    ];
  }

  return [
    heading(2, 'API Surface'),
    table(
      ['Method', 'Path', 'Description'],
      repo.apiEndpoints.map((e) => [e.method, e.path, e.description]),
    ),
  ];
}

function glossarySection(repo: RepoAnalysis): JSONContent[] {
  if (repo.glossary.length === 0) return [];
  return [
    heading(2, 'Domain Glossary'),
    paragraph('Non-obvious terms found in the codebase with inferred definitions:'),
    table(
      ['Term', 'Definition'],
      repo.glossary.map((g) => [g.term, g.inferredDefinition]),
    ),
  ];
}

function errorSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.errorPatterns.length === 0) return [];
  return [
    heading(2, 'Error Taxonomy'),
    paragraph('Custom error classes and their meanings:'),
    table(
      ['Error Class', 'Message'],
      repo.errorPatterns.map((e) => [e.className, e.message]),
    ),
  ];
}

function archDecisionsSection(repo: RepoAnalysis): JSONContent[] {
  if (repo.archDecisions.length === 0) return [];
  return [
    heading(2, 'Architecture Decisions'),
    paragraph('Key technical decisions extracted from commit messages, PRs, and ADRs:'),
    ...repo.archDecisions.map((d) => [
      heading(3, `${d.date} — ${d.summary}`),
      paragraph(`Source: ${d.source}`),
      blockquote(d.context),
    ]).flat(),
  ];
}

// ─── Architecture Diagram Node ────────────────────────────────

/**
 * Builds an `archDiagram` node that the ArchDiagramExtension renders via ReactFlow.
 * Each repo becomes a service node; connections become edges.
 * For single-repo analyses we also show tech stack components.
 */
function archDiagramNode(result: GodModeAnalysisResult): JSONContent {
  interface DiagramNode {
    id: string;
    label: string;
    type: 'service' | 'tech' | 'external';
    role?: string;
    techStack?: string[];
    description?: string;
  }
  interface DiagramEdge {
    from: string;
    to: string;
    label: string;
    type: string;
  }

  const nodes: DiagramNode[] = [];
  const edges: DiagramEdge[] = [];

  // Add a node for each repo
  for (const repo of result.repos) {
    nodes.push({
      id: repo.repoId,
      label: repo.repoName,
      type: 'service',
      role: repo.repoRole,
      techStack: repo.techStack.slice(0, 6),
      description: repo.description,
    });
  }

  // Add connections between repos as edges
  const allConnections = result.repos.flatMap((r) => r.connections);
  for (const conn of allConnections) {
    // Resolve repo ids from names
    const fromRepo = result.repos.find((r) => r.repoName === conn.fromRepo);
    const toRepo = result.repos.find((r) => r.repoName === conn.toRepo);
    if (fromRepo && toRepo) {
      edges.push({
        from: fromRepo.repoId,
        to: toRepo.repoId,
        label: conn.description || conn.connectionType,
        type: conn.connectionType,
      });
    }
  }

  // For single-repo analyses, add tech stack items as satellite nodes
  if (result.repos.length === 1) {
    const repo = result.repos[0];

    // Detect external dependencies from tech stack
    const externalKeywords: Record<string, string> = {
      'PostgreSQL': 'Database',
      'MySQL': 'Database',
      'MongoDB': 'Database',
      'Redis': 'Cache',
      'Elasticsearch': 'Search',
      'RabbitMQ': 'Queue',
      'Kafka': 'Queue',
      'Docker': 'Infrastructure',
      'Kubernetes': 'Infrastructure',
      'AWS': 'Cloud',
      'GCP': 'Cloud',
      'Azure': 'Cloud',
    };

    for (const tech of repo.techStack) {
      const category = Object.entries(externalKeywords).find(([key]) =>
        tech.toLowerCase().includes(key.toLowerCase())
      );
      if (category) {
        const nodeId = `tech-${tech.toLowerCase().replace(/\s+/g, '-')}`;
        nodes.push({
          id: nodeId,
          label: tech,
          type: 'external',
          description: category[1],
        });
        edges.push({
          from: repo.repoId,
          to: nodeId,
          label: category[1],
          type: 'dependency',
        });
      }
    }

    // Add CI/CD as a node if present
    if (repo.cicdPlatform && repo.cicdPlatform !== 'Unknown') {
      const cicdId = 'cicd-platform';
      nodes.push({
        id: cicdId,
        label: repo.cicdPlatform,
        type: 'external',
        description: 'CI/CD',
      });
      edges.push({
        from: repo.repoId,
        to: cicdId,
        label: 'CI/CD',
        type: 'dependency',
      });
    }
  }

  return {
    type: 'archDiagram',
    attrs: {
      diagramData: JSON.stringify({ nodes, edges }),
    },
  };
}

// ─── TipTap Node Helpers ──────────────────────────────────────

/**
 * ProseMirror text nodes require a non-empty string.
 * Null, undefined, or empty-string values cause the entire document to
 * silently fail to render, so we coerce them to a dash placeholder.
 */
function safeText(value: unknown): string {
  if (value === null || value === undefined) return '—';
  const s = String(value).trim();
  return s.length > 0 ? s : '—';
}

function heading(level: number, text: string): JSONContent {
  return {
    type: 'heading',
    attrs: { level },
    content: [{ type: 'text', text: safeText(text) }],
  };
}

function paragraph(text: string): JSONContent {
  return {
    type: 'paragraph',
    content: [{ type: 'text', text: safeText(text) }],
  };
}

function horizontalRule(): JSONContent {
  return { type: 'horizontalRule' };
}

function bulletList(items: string[]): JSONContent {
  return {
    type: 'bulletList',
    content: items.map((item) => ({
      type: 'listItem',
      content: [{ type: 'paragraph', content: [{ type: 'text', text: safeText(item) }] }],
    })),
  };
}

function orderedList(items: string[]): JSONContent {
  return {
    type: 'orderedList',
    attrs: { start: 1 },
    content: items.map((item) => ({
      type: 'listItem',
      content: [{ type: 'paragraph', content: [{ type: 'text', text: safeText(item) }] }],
    })),
  };
}

function blockquote(text: string): JSONContent {
  return {
    type: 'blockquote',
    content: [{ type: 'paragraph', content: [{ type: 'text', text: safeText(text) }] }],
  };
}

function swaggerPlaceholder(): JSONContent {
  return {
    type: 'blockquote',
    content: [
      {
        type: 'paragraph',
        content: [
          { type: 'text', marks: [{ type: 'bold' }], text: 'Swagger / OpenAPI Documentation' },
        ],
      },
      {
        type: 'paragraph',
        content: [
          {
            type: 'text',
            text: 'A Swagger embed will be placed here. You can configure the API spec URL after creating the document.',
          },
        ],
      },
    ],
  };
}

function table(headers: string[], rows: string[][]): JSONContent {
  // TipTap requires at least one data row — add an empty row if needed
  const dataRows = rows.length > 0
    ? rows
    : [headers.map(() => '—')];

  return {
    type: 'table',
    content: [
      {
        type: 'tableRow',
        content: headers.map((h) => ({
          type: 'tableHeader',
          attrs: { colspan: 1, rowspan: 1 },
          content: [{ type: 'paragraph', content: [{ type: 'text', text: safeText(h) }] }],
        })),
      },
      ...dataRows.map((row) => ({
        type: 'tableRow',
        content: row.map((cell) => ({
          type: 'tableCell',
          attrs: { colspan: 1, rowspan: 1 },
          content: [{ type: 'paragraph', content: [{ type: 'text', text: safeText(cell) }] }],
        })),
      })),
    ],
  };
}
